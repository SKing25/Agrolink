\documentclass[12pt]{article}
\usepackage[utf8]{inputenc} %tildes
\usepackage[spanish]{babel}
\usepackage{enumerate}
\usepackage{fancyhdr}
\usepackage{xcolor}
\usepackage{float}
\usepackage{graphicx}
\usepackage{color}
\usepackage{caption}
\usepackage{mathtools}
\usepackage{newunicodechar}
\newunicodechar{₂}{$_2$}
\usepackage{amsmath}
\usepackage{tikz}
\usepackage{amssymb}
\usepackage{xspace}
\usepackage{cancel}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{caption}
\usepackage{hyperref} 

\hypersetup{
    colorlinks=false,  % No colorear enlaces
    pdfborder={0 0 0}  % Quitar borde alrededor de los enlaces
}

\setlength{\oddsidemargin}{0.5cm}
\setlength{\evensidemargin}{0.5cm}
\setlength{\topmargin}{-1.6cm}
\setlength{\leftmargin}{0.5cm}
\setlength{\rightmargin}{0.5cm}
\setlength{\textheight}{24.00cm} 
\setlength{\textwidth}{15.00cm}
\parindent 0pt
\parskip 5pt

%%%%%%%%ESTILO DEL DOCUMENTO%%%%%%%%%%%%%%%
\usepackage{fancyhdr}
\pagestyle{fancy}
\title{
\textbf{Agrolink}: Sistema IoT con Red Mesh ESP32 y Monitoreo de Sensores DHT22
}
\author{}
\date{}
\renewcommand{\headrulewidth}{0pt}
\renewcommand{\footrulewidth}{0pt}
\setlength\headheight{35.0pt}
\addtolength{\textheight}{-35.0pt}
\newcommand{\namelistlabel}[1]{\mbox{#1}\hfil}
\newenvironment{namelist}[1]{%1
\begin{list}{}
    {
        \let\makelabel\namelistlabel
        \settowidth{\labelwidth}{#1}
        \setlength{\leftmargin}{1.1\labelwidth}
    }
  }{%1
\end{list}}

\rhead{\begin{picture}(0,0) \put(-56.7,0){\includegraphics[width=30mm]{usa.png}} \end{picture}}
\renewcommand{\headrulewidth}{0.5pt}

\newtheorem{problem}{Punto}
\newtheorem{definition}{Definición}
\newtheorem{theorem}{Teorema}
\newtheorem{conjeture}{Conjetura}
\newtheorem{lemma}{Lema}[theorem]
\newtheorem{proposition}{Proposición}
\newtheorem{corollary}{Corolario}[theorem]

\pagestyle{fancy}

%%%%%%%%%%INICIO DEL DOCUMENTO%%%%%%%%%%%%%%%%%
\begin{document}

\maketitle

\begin{figure}[!t]
\centering
\includegraphics[scale = 0.4]{usa.png}
\end{figure}

%%%%%%%IDENTIFICACIÓN%%%%%%%%%%%%
\begin{center}
{\Large \bf Redes de computación}
\vskip 0.5cm 
{\bf Yslen Natalia Moreno  \\  Camilo Andrés Diaz Garcia\\ Santiago José Rodríguez Gutiérrez} 
\vskip 2cm
{\it  Universidad Sergio Arboleda \\Escuela de ciencias exactas e ingenier\'ia \\ 
Bogot\'a D.C., 15 de septiembre de 2025}
\end{center}

\clearpage
%%%%%%%%%%CUERPO DEL DOCUMENTO%%%%%%%%%%%%%%%%%%%%%%%
\tableofcontents
\newpage 

\section{Resumen Ejecutivo}

Este proyecto implementa un sistema completo de Internet de las Cosas (IoT) para monitoreo ambiental utilizando sensores DHT22 conectados a través de una red mesh de ESP32. El sistema recolecta datos de temperatura y humedad, los transmite a través de MQTT y los almacena en un servidor web en la nube para visualización y análisis.

\section{Arquitectura del Sistema}

\begin{verbatim}
[ESP32 DHT22] --> [Red Mesh] --> [ESP32 Gateway] --> 
[Mosquitto MQTT] --> [Puente Python] --> [Servidor Flask/Render]
\end{verbatim}

\subsection{Componentes principales}
\begin{enumerate}
    \item \textbf{Nodo Sensor (ESP32 + DHT22):} Recolección de datos ambientales
    \item \textbf{Gateway ESP32:} Puente entre red mesh y conectividad externa
    \item \textbf{Broker MQTT (Mosquitto):} Middleware de mensajería
    \item \textbf{Puente Python:} Procesamiento y reenvío de datos
    \item \textbf{Servidor Web Flask:} Almacenamiento y visualización de datos
\end{enumerate}

\section{Conceptos Fundamentales}

\subsection{Red Mesh}
Una red mesh es una topología de red donde cada nodo se conecta directamente con varios otros nodos, creando múltiples rutas para la transmisión de datos. En este proyecto:

\begin{itemize}
    \item \textbf{Ventajas:} Redundancia, autoconfiguración, escalabilidad
    \item \textbf{Protocolo:} PainlessMesh sobre ESP32
    \item \textbf{Alcance:} Cada nodo extiende el área de cobertura
    \item \textbf{Autorecuperación:} Si un nodo falla, la red se reconfigura automáticamente
\end{itemize}

\subsection{MQTT (Message Queuing Telemetry Transport)}
Protocolo de comunicación ligero diseñado para dispositivos IoT:

\begin{itemize}
    \item \textbf{Patrón Publish/Subscribe:} Los dispositivos publican mensajes a topics específicos
    \item \textbf{Broker:} Servidor central (Mosquitto) que gestiona la distribución de mensajes
    \item \textbf{QoS:} Niveles de calidad de servicio para garantizar entrega
    \item \textbf{Eficiencia:} Bajo consumo de ancho de banda y batería
\end{itemize}

\subsection{Mosquitto}
Broker MQTT open source que implementa las versiones 3.1, 3.1.1 y 5.0 del protocolo:

\begin{itemize}
    \item \textbf{Funciones:} Recepción, filtrado y distribución de mensajes
    \item \textbf{Configuración:} Servidor local en IP 10.42.0.1
    \item \textbf{Topics:} Estructura jerárquica para organizar mensajes (dht22/datos/+)
\end{itemize}

\subsection{Broker (Intermediario de Mensajes)}
Un broker es un servidor intermediario que facilita la comunicación entre diferentes sistemas:

\begin{itemize}
    \item \textbf{Función principal:} Recibir, almacenar temporalmente y distribuir mensajes
    \item \textbf{Desacoplamiento:} Los emisores no necesitan conocer a los receptores directamente
    \item \textbf{Escalabilidad:} Permite múltiples productores y consumidores simultáneos
    \item \textbf{Ejemplo en el proyecto:} Mosquitto actúa como broker MQTT entre ESP32 Gateway y aplicaciones Python
\end{itemize}

\subsection{Middleware (Capa Intermedia)}
Software que actúa como puente entre diferentes aplicaciones, sistemas operativos o bases de datos:

\begin{itemize}
    \item \textbf{Propósito:} Facilitar la comunicación e integración entre sistemas heterogéneos
    \item \textbf{Características:} Transparencia, interoperabilidad, servicios distribuidos
    \item \textbf{Tipos:} Message-oriented middleware (MOM), database middleware, web middleware
    \item \textbf{En este proyecto:} MQTT actúa como middleware de mensajería IoT
\end{itemize}

\subsection{WiFi vs MQTT: Infraestructura vs Protocolo}

\subsubsection{WiFi: La Infraestructura de Conectividad}
\textbf{WiFi proporciona:}
\begin{enumerate}
    \item \textbf{Conectividad física inalámbrica} entre ESP32 Gateway y la computadora
    \item \textbf{Asignación de IP} al ESP32 Gateway (ej: 10.42.0.100)
    \item \textbf{Acceso a la red local} creada por el hotspot "Laptop-Santiago"
    \item \textbf{Canal de comunicación} bidireccional
\end{enumerate}

\subsubsection{MQTT: El Protocolo de Datos}
\textbf{MQTT utiliza la conectividad WiFi para:}
\begin{enumerate}
    \item \textbf{Transportar mensajes} estructurados
    \item \textbf{Organizar datos} por topics
    \item \textbf{Gestionar suscripciones} y publicaciones
    \item \textbf{Manejar la lógica} de entrega de mensajes
\end{enumerate}

\subsubsection{Relación entre WiFi y MQTT (Capas de Red)}
\begin{verbatim}
┌─────────────────────────────────────┐
│ APLICACIÓN: Datos del DHT22         │
├─────────────────────────────────────┤
│ MQTT: Protocolo de mensajería       │ ← Organiza QUÉ enviar
├─────────────────────────────────────┤
│ TCP: Conexión confiable             │
├─────────────────────────────────────┤
│ IP: Enrutamiento (10.42.0.X)       │
├─────────────────────────────────────┤
│ WiFi: Transmisión inalámbrica       │ ← Define CÓMO enviar
└─────────────────────────────────────┘
\end{verbatim}

\section{Los Tres Puentes del Sistema}

El sistema implementa \textbf{tres puentes tecnológicos} que permiten el flujo de datos desde sensores locales hasta servicios en la nube:

\subsection{Puente 1: ESP32 Gateway (Mesh $\leftrightarrow$ WiFi/MQTT)}
\begin{itemize}
    \item \textbf{Función:} Traductor entre protocolos de red
    \item \textbf{Entrada:} Red mesh PainlessMesh
    \item \textbf{Salida:} WiFi + protocolo MQTT
    \item \textbf{Ubicación:} ESP32 con doble conectividad
\end{itemize}

\subsection{Puente 2: Mosquitto (Dispositivos $\leftrightarrow$ Aplicaciones)}
\begin{itemize}
    \item \textbf{Función:} Broker/intermediario de mensajes
    \item \textbf{Entrada:} Mensajes MQTT de dispositivos IoT
    \item \textbf{Salida:} Distribución MQTT a aplicaciones suscritas
    \item \textbf{Ubicación:} Computadora local (puerto 1883)
\end{itemize}

\subsection{Puente 3: Script Python (Local $\leftrightarrow$ Nube)}
\begin{itemize}
    \item \textbf{Función:} Adaptador de protocolos y transformador de datos
    \item \textbf{Entrada:} Mensajes MQTT locales
    \item \textbf{Salida:} Requests HTTP/HTTPS hacia servicios cloud
    \item \textbf{Ubicación:} Computadora local con acceso a Internet
\end{itemize}

\section{El Viaje del Dato: Desde el Sensor hasta la Nube}

Este proyecto demuestra un flujo completo de datos IoT que atraviesa múltiples capas tecnológicas. A continuación se detalla el recorrido paso a paso que realiza cada medición desde su origen hasta su visualización final.

\subsection{Etapa 1: Captura de Datos Físicos}
\textbf{Ubicación:} ESP32 con sensor DHT22\\
\textbf{Duración:} $\sim$2 segundos\\
\textbf{Tecnología:} Protocolo One-Wire

\begin{enumerate}
    \item \textbf{Activación del sensor:} El ESP32 envía una señal de inicio al DHT22
    \item \textbf{Medición física:} El sensor DHT22 realiza mediciones de:
    \begin{itemize}
        \item Temperatura ambiente (precisión $\pm$0.5°C)
        \item Humedad relativa (precisión $\pm$2-5\% RH)
    \end{itemize}
    \item \textbf{Digitalización:} Conversión analógico-digital interna del sensor
    \item \textbf{Transmisión serie:} Datos enviados al ESP32 vía protocolo propietario DHT
    \item \textbf{Validación:} ESP32 verifica checksums y detecta errores de lectura
\end{enumerate}

\textbf{Formato de datos en esta etapa:} Valores float en memoria del ESP32

\subsection{Etapa 2: Procesamiento Local y Empaquetado}
\textbf{Ubicación:} ESP32 Nodo Sensor\\
\textbf{Duración:} $\sim$500 ms\\
\textbf{Tecnología:} C++ en microcontrolador

\begin{enumerate}
    \item \textbf{Validación de datos:} Verificación de valores NaN (Not a Number)
    \item \textbf{Construcción de mensaje:} Creación de estructura JSON
    \item \textbf{Preparación para transmisión:} Serialización del objeto JSON a string
    \item \textbf{Identificación de destino:} Configuración para broadcast mesh
\end{enumerate}

\subsection{Etapa 3: Transmisión por Red Mesh}
\textbf{Ubicación:} Entre nodos ESP32\\
\textbf{Duración:} $\sim$100-500 ms\\
\textbf{Tecnología:} WiFi 802.11 con protocolo PainlessMesh

\begin{enumerate}
    \item \textbf{Encapsulación mesh:} Mensaje envuelto en cabeceras de red mesh
    \item \textbf{Enrutamiento automático:} PainlessMesh determina la ruta óptima
    \item \textbf{Transmisión inalámbrica:} Envío vía radiofrecuencia 2.4GHz
    \item \textbf{Retransmisión:} Posibles saltos entre nodos intermedios si existen
    \item \textbf{Recepción en gateway:} ESP32 Gateway recibe el mensaje broadcast
\end{enumerate}

\textbf{Características de la transmisión:}
\begin{itemize}
    \item Protocolo: ESP-NOW sobre WiFi
    \item Alcance: $\sim$30-100 metros por salto
    \item Velocidad: $\sim$1-2 Mbps
    \item Redundancia: Múltiples rutas disponibles
\end{itemize}

\subsection{Etapa 4: Puente a Infraestructura Tradicional}
\textbf{Ubicación:} ESP32 Gateway\\
\textbf{Duración:} $\sim$200 ms\\
\textbf{Tecnología:} WiFi cliente + MQTT

\begin{enumerate}
    \item \textbf{Recepción mesh:} Callback \texttt{receivedCallback()} procesa mensaje entrante
    \item \textbf{Identificación de origen:} Extracción del nodeId del remitente
    \item \textbf{Conexión dual:} Gateway mantiene conexión a red mesh Y WiFi externo
    \item \textbf{Construcción de topic:} Creación de topic MQTT específico por nodo
    \item \textbf{Publicación MQTT:} Envío a broker Mosquitto local
\end{enumerate}

\subsection{Etapa 5: Distribución por Middleware MQTT}
\textbf{Ubicación:} Servidor local (10.42.0.1)\\
\textbf{Duración:} $\sim$50 ms\\
\textbf{Tecnología:} Broker Mosquitto

\begin{enumerate}
    \item \textbf{Recepción en broker:} Mosquitto recibe mensaje del ESP32 Gateway
    \item \textbf{Gestión de topics:} Organización jerárquica de mensajes
    \item \textbf{Distribución a suscriptores:} Notificación a todos los clientes suscritos
    \item \textbf{Persistencia temporal:} Retención de último mensaje por topic
    \item \textbf{Entrega garantizada:} Confirmación de recepción según QoS configurado
\end{enumerate}

\subsection{Etapa 6: Procesamiento y Transformación}
\textbf{Ubicación:} Computadora local\\
\textbf{Duración:} $\sim$100-300 ms\\
\textbf{Tecnología:} Python con paho-mqtt y requests

\begin{enumerate}
    \item \textbf{Suscripción MQTT:} Cliente Python escucha topic \texttt{dht22/datos/+}
    \item \textbf{Recepción de mensaje:} Callback \texttt{on\_message()} activado
    \item \textbf{Decodificación:} Conversión de bytes a string UTF-8
    \item \textbf{Parsing JSON:} Deserialización del mensaje JSON
    \item \textbf{Enriquecimiento:} Adición de metadatos (timestamp, nodeId)
    \item \textbf{Validación:} Verificación de campos requeridos
    \item \textbf{Preparación HTTP:} Serialización para envío web
\end{enumerate}

\subsection{Etapa 7: Transmisión a la Nube}
\textbf{Ubicación:} Internet\\
\textbf{Duración:} $\sim$200-1000 ms\\
\textbf{Tecnología:} HTTP/HTTPS sobre TCP/IP

\begin{enumerate}
    \item \textbf{Establecimiento de conexión:} TCP handshake con servidor Render
    \item \textbf{Negociación TLS:} Cifrado HTTPS para seguridad
    \item \textbf{Envío HTTP POST:} Datos JSON en body de request
    \item \textbf{Enrutamiento ISP:} Paso por múltiples routers hasta datacenter
    \item \textbf{Balanceador de carga:} Distribución en infraestructura Render
    \item \textbf{Recepción en servidor:} Flask recibe request en endpoint \texttt{/datos}
\end{enumerate}

\subsection{Etapa 8: Persistencia en Base de Datos}
\textbf{Ubicación:} Servidor Render (Cloud)\\
\textbf{Duración:} $\sim$50-200 ms\\
\textbf{Tecnología:} Flask + SQLAlchemy + SQLite

\begin{enumerate}
    \item \textbf{Recepción en Flask:} Endpoint \texttt{/datos} procesa request POST
    \item \textbf{Validación de datos:} Verificación de campos requeridos
    \item \textbf{Creación de objeto:} Instanciación de modelo \texttt{DatosSensor}
    \item \textbf{Transacción de BD:} Inserción en tabla SQLite
    \item \textbf{Confirmación:} Commit de transacción
    \item \textbf{Respuesta HTTP:} Confirmación 200 OK al cliente
\end{enumerate}

\subsection{Etapa 9: Visualización Web}
\textbf{Ubicación:} Navegador del usuario\\
\textbf{Duración:} $\sim$500-2000 ms\\
\textbf{Tecnología:} HTTP + HTML + JavaScript

\begin{enumerate}
    \item \textbf{Request del navegador:} GET a \texttt{/ver} desde cualquier ubicación
    \item \textbf{Consulta a BD:} Flask recupera últimos 100 registros
    \item \textbf{Renderizado:} Jinja2 genera HTML con datos
    \item \textbf{Transmisión HTTP:} Página enviada al navegador
    \item \textbf{Renderizado local:} Browser muestra tabla de datos
    \item \textbf{Auto-refresh:} JavaScript recarga página cada 30 segundos
\end{enumerate}

\subsection{Resumen del Viaje Completo}

\textbf{Tiempo total:} 3-6 segundos (desde medición hasta visualización)\\
\textbf{Distancia física:} Desde sensor local hasta datacenter (potencialmente miles de km)\\
\textbf{Transformaciones de protocolo:} 6 diferentes (DHT $\rightarrow$ ESP32 $\rightarrow$ Mesh $\rightarrow$ MQTT $\rightarrow$ HTTP $\rightarrow$ SQL)\\
\textbf{Puntos de validación:} 4 capas de verificación de datos\\
\textbf{Tecnologías involucradas:} 8+ diferentes sistemas

\textbf{Cronología típica:}
\begin{verbatim}
T+0.0s: DHT22 inicia medición
T+2.0s: Datos listos en ESP32
T+2.5s: Transmisión mesh completa
T+2.7s: Publicación MQTT realizada
T+2.8s: Python procesa mensaje
T+3.8s: HTTP POST enviado a nube
T+4.0s: Datos persistidos en BD
T+4.1s: Usuario puede ver datos en web
\end{verbatim}

Este flujo demuestra la complejidad y elegancia de los sistemas IoT modernos, donde una simple medición de temperatura atraviesa múltiples dominios tecnológicos para convertirse en información accesible globalmente.

\section{Confirmación del Flujo de Datos del Sistema}

\subsection{Flujo Completo Verificado}

\subsubsection{1. ESP32 DHT22 $\rightarrow$ ESP32 Gateway (Red Mesh)}
\begin{itemize}
    \item ESP32 con DHT22 captura temperatura y humedad cada 10 segundos
    \item Envía datos vía \textbf{red mesh inalámbrica} al Gateway usando PainlessMesh
    \item No requiere WiFi externo, solo conectividad mesh local
    \item Formato: JSON con temperature y humidity
\end{itemize}

\subsubsection{2. ESP32 Gateway $\rightarrow$ Computadora (WiFi + MQTT)}
\begin{itemize}
    \item Gateway \textbf{DEBE} estar conectado al mismo WiFi que la computadora
    \item En este proyecto: ambos conectados a hotspot "Laptop-Santiago" (10.42.0.1)
    \item Gateway actúa como \textbf{traductor} entre red mesh y WiFi externo
    \item Envía datos vía \textbf{protocolo MQTT} a Mosquitto (puerto 1883)
    \item Topic utilizado: \texttt{dht22/datos/\{nodeId\}}
\end{itemize}

\subsubsection{3. Mosquitto $\rightarrow$ Python $\rightarrow$ Nube}
\begin{itemize}
    \item \textbf{Mosquitto} recibe y organiza los datos MQTT por topics
    \item \textbf{Código Python} se suscribe automáticamente a \texttt{dht22/datos/+}
    \item \textbf{Python} transforma datos y los envía al servidor Flask vía HTTPS
    \item \textbf{Servidor Flask} almacena en base de datos SQLite y presenta vía web
\end{itemize}

\subsection{Requisitos de Conectividad}

\subsubsection{Configuración Necesaria}
\begin{enumerate}
    \item \textbf{ESP32 DHT22:} Solo red mesh "MeshNetwork" (sin WiFi externo)
    \item \textbf{ESP32 Gateway:} Red mesh + WiFi "Laptop-Santiago" (conectividad dual)
    \item \textbf{Computadora:} WiFi "Laptop-Santiago" + Mosquitto en puerto 1883
    \item \textbf{Script Python:} Mismo equipo que Mosquitto + acceso a Internet
    \item \textbf{Servidor Render:} Accesible vía HTTPS desde Internet
\end{enumerate}

\subsubsection{Lo que NO se requiere}
\begin{itemize}
    \item ESP32 DHT22 no necesita WiFi externo ni acceso a Internet
    \item Gateway no necesita acceso directo a Internet (solo WiFi local)
    \item Solo la computadora necesita conexión completa a Internet
\end{itemize}

\section{Guía de Implementación Paso a Paso}

Esta sección detalla el proceso completo de implementación del sistema, desde la programación de los ESP32 hasta el despliegue del servidor en la nube.

\subsection{Paso 1: Programación del ESP32 con Sensor DHT22}

\subsubsection{Preparación del Hardware}
\begin{itemize}
    \item \textbf{Componentes:} ESP32, sensor DHT22, resistencia pull-up 10k$\Omega$, cables
    \item \textbf{Conexiones:}
    \begin{verbatim}
    DHT22 VCC  → ESP32 3.3V
    DHT22 DATA → ESP32 Pin 4 (con resistencia pull-up)
    DHT22 GND  → ESP32 GND
    \end{verbatim}
\end{itemize}

\subsubsection{Configuración del Código (NODO\_DHT22.cpp)}
\begin{lstlisting}[language=C++, basicstyle=\small\ttfamily]
#include <painlessMesh.h>
#include <DHT.h>

#define MESH_PREFIX "Mesh"
#define MESH_PASSWORD "12345678"
#define MESH_PORT 5555
#define DHTPIN 4
#define DHTTYPE DHT22

// Configuración y código del nodo sensor...
\end{lstlisting}

\subsubsection{Compilación y Carga}
\begin{enumerate}
    \item Abrir PlatformIO en VS Code
    \item Crear nuevo proyecto ESP32
    \item Agregar dependencias en \texttt{platformio.ini}
    \item Copiar código a \texttt{src/main.cpp}
    \item Compilar: \texttt{PlatformIO: Build}
    \item Cargar: \texttt{PlatformIO: Upload}
    \item Verificar funcionamiento: \texttt{PlatformIO: Serial Monitor}
\end{enumerate}

\subsection{Paso 2: Programación del ESP32 Gateway}

\subsubsection{Configuración del Hardware}
\begin{itemize}
    \item \textbf{Componentes:} ESP32 (sin sensores adicionales)
    \item \textbf{Ubicación:} Punto intermedio entre red mesh y computadora
\end{itemize}

\subsubsection{Configuración del Código (GATEWAY.cpp)}
\begin{lstlisting}[language=C++, basicstyle=\small\ttfamily]
#include <painlessMesh.h>
#include <WiFi.h>
#include <PubSubClient.h>

#define MESH_PREFIX "Mesh"
#define MESH_PASSWORD "12345678"
#define MESH_PORT 5555
#define WIFI_SSID "Laptop-Santiago"
#define WIFI_PASSWORD "salchipapa123"
#define MQTT_SERVER "10.42.0.1"
#define MQTT_PORT 1883

// Configuración y código del gateway...
\end{lstlisting}

\subsection{Paso 3: Configuración de Mosquitto en la Computadora}

\subsubsection{Instalación de Mosquitto}
\begin{verbatim}
# Ubuntu/Debian
sudo apt update
sudo apt install mosquitto mosquitto-clients

# Verificar instalación
mosquitto --version
\end{verbatim}

\subsubsection{Configuración del Hotspot WiFi}
\begin{enumerate}
    \item Crear hotspot con nombre "Laptop-Santiago"
    \item Configurar contraseña "salchipapa123"
    \item Verificar IP asignada (debe ser 10.42.0.1)
\end{enumerate}

\subsubsection{Inicio del Broker Mosquitto}
\begin{verbatim}
# Iniciar Mosquitto
sudo systemctl start mosquitto
sudo systemctl enable mosquitto

# Verificar que está corriendo
sudo systemctl status mosquitto

# Probar funcionamiento
mosquitto_sub -h localhost -t "test" &
mosquitto_pub -h localhost -t "test" -m "Hello World"
\end{verbatim}

\subsection{Paso 4: Implementación del Puente Python}

\subsubsection{Instalación de Dependencias}
\begin{verbatim}
# Crear entorno virtual (recomendado)
python3 -m venv mqtt_bridge_env
source mqtt_bridge_env/bin/activate

# Instalar librerías necesarias
pip install paho-mqtt requests
\end{verbatim}

\subsubsection{Configuración del Script (puente.py)}
\begin{lstlisting}[language=Python, basicstyle=\small\ttfamily]
import paho.mqtt.client as mqtt
import requests
import json
import time

BROKER = "localhost"
PORT = 1883
TOPIC = "dht22/datos/+"
SERVER_URL = "https://agrolink-hd2p.onrender.com/datos"

# Código completo del puente...
\end{lstlisting}

\subsection{Paso 5: Desarrollo y Despliegue del Servidor Flask}

\subsubsection{Desarrollo Local del Servidor}
\begin{lstlisting}[language=Python, basicstyle=\small\ttfamily]
# app.py
from flask import Flask, request, jsonify, render_template
from flask_sqlalchemy import SQLAlchemy
from datetime import datetime

app = Flask(__name__)
app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///datos_sensores.db'
db = SQLAlchemy(app)

# Código completo del servidor Flask...
\end{lstlisting}

\subsubsection{Preparación para Despliegue}
\begin{enumerate}
    \item Crear \texttt{requirements.txt}
    \item Crear \texttt{templates/dht22.html} para visualización web
    \item Configurar Web Service en Render.com
    \item Desplegar y obtener URL pública
\end{enumerate}

\subsection{Paso 6: Verificación del Sistema Completo}

\subsubsection{Prueba End-to-End}
\begin{enumerate}
    \item \textbf{Verificar ESP32 DHT22:} Monitor serial muestra lectura de sensores
    \item \textbf{Verificar ESP32 Gateway:} Monitor serial muestra recepción mesh y envío MQTT
    \item \textbf{Verificar Mosquitto:} \texttt{mosquitto\_sub} muestra mensajes entrantes
    \item \textbf{Verificar Puente Python:} Script muestra envío exitoso a servidor
    \item \textbf{Verificar Servidor:} Acceder a URL pública y ver datos en tabla
\end{enumerate}

\subsubsection{Comandos de Diagnóstico}
\begin{verbatim}
# Verificar conexión de red
ping 10.42.0.1

# Verificar Mosquitto
mosquitto_sub -h localhost -t "dht22/datos/+" -v

# Verificar servidor remoto
curl -X GET https://tu-app.onrender.com/api/datos

# Verificar logs del puente
python3 puente.py
\end{verbatim}

\subsubsection{Métricas de Funcionamiento}
\begin{itemize}
    \item \textbf{Frecuencia de datos:} Cada 10 segundos desde ESP32 DHT22
    \item \textbf{Latencia típica:} 3-6 segundos desde sensor hasta visualización web
    \item \textbf{Disponibilidad:} 24/7 una vez configurado correctamente
\end{itemize}

\section{Consideraciones Técnicas}

\subsection{Escalabilidad}
\begin{itemize}
    \item La red mesh soporta múltiples nodos sensor
    \item Cada nodo se identifica únicamente
    \item Base de datos diseñada para crecimiento
\end{itemize}

\subsection{Confiabilidad}
\begin{itemize}
    \item Reconexión automática en todos los niveles
    \item Validación de datos en múltiples puntos
    \item Manejo de errores y logging detallado
\end{itemize}

\subsection{Seguridad}
\begin{itemize}
    \item Contraseña para red mesh
    \item Comunicación local para MQTT
    \item HTTPS para servidor remoto (Render)
\end{itemize}

\subsection{Eficiencia Energética}
\begin{itemize}
    \item Transmisión cada 10 segundos (configurable)
    \item Protocolo MQTT optimizado para IoT
    \item Operación de baja potencia en ESP32
\end{itemize}

\section{Conclusiones}

El sistema implementado demuestra una arquitectura robusta para monitoreo IoT con las siguientes características:

\begin{enumerate}
    \item \textbf{Modularidad:} Cada componente tiene responsabilidades específicas
    \item \textbf{Escalabilidad:} Fácil adición de nuevos sensores
    \item \textbf{Confiabilidad:} Múltiples niveles de redundancia
    \item \textbf{Accesibilidad:} Datos disponibles via web desde cualquier ubicación
    \item \textbf{Mantenibilidad:} Código bien estructurado y documentado
\end{enumerate}

Este enfoque proporciona una base sólida para sistemas de monitoreo ambiental distribuidos, con potencial de expansión para incluir diferentes tipos de sensores y aplicaciones de análisis más avanzadas.

La implementación exitosa de los tres puentes tecnológicos (ESP32 Gateway, Mosquitto, y Puente Python) demuestra cómo diferentes protocolos y tecnologías pueden integrarse de manera efectiva para crear soluciones IoT complejas y funcionales.

\begin{thebibliography}{10}

\bibitem{aichele2008batman}
Aichele, C.; Lindner, M.; Nuemann, A.; Wunderlich, S. (2008). 
\textit{Better Approach To Mobile Ad-hoc Networking (B.A.T.M.A.N.)}. 
IETF, Internet-Draft.

\bibitem{jungic2011batman}
Jungic, D. (2011). 
\textit{A Better Approach to Mobile Ad hoc Networking: Analysis through Simulation using NS2}. 
Final Project Presentation, ENSC 427: Communication Networks, Simon Fraser University.

\bibitem{espressif2025esp32}
Espressif Systems. (2025). 
\textit{ESP32 Series Datasheet and Product Overview}. 
Disponible en: \url{https://www.espressif.com/en/products/socs/esp32} [Accedido: 15 de septiembre de 2025].

\bibitem{datageneral-router-gateway}
Data General. (2023). \textit{Router vs Gateway: Function and Usefulness}. Disponible en: \url{https://datageneral.co/router-vs-gateway/} [Consultado: 15 de septiembre de 2025].

\bibitem{sciencedirect_multihop}
ScienceDirect, "Wireless Multihop Network – an overview", ScienceDirect Topics, Elsevier. Disponible en: \url{https://www.sciencedirect.com/topics/computer-science/wireless-multihop-network}.

\end{thebibliography}

\end{document}
